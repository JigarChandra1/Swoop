<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SWOOP ‚Äî Pass & Play (3 dice, choose any pair) ‚Äî v5.2 (Save/Load)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#f6f7fb; --card:#ffffff; --ink:#1f2937; --muted:#6b7280;
  --accent:#2563eb; --tile:#eef0f3; --cp:#f5e5a3; --det:#f3b0a3; --center:#e6e1d6;
  --line:#c9cfd8; --danger:#ef4444;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#1f2937}
.wrap{max-width:1160px;margin:28px auto 56px;padding:0 16px;}
h1{margin:0 0 10px;font-weight:800;letter-spacing:.2px}
.badges{display:flex;gap:14px;align-items:center;float:right}
.badge{background:#fff;border:1px solid var(--line);border-radius:12px;padding:6px 12px;box-shadow:0 3px 10px rgba(0,0,0,.06);display:flex;gap:8px;align-items:center}
.controls{display:flex;gap:10px;margin:8px 0 12px;flex-wrap:wrap}
button{border:0;border-radius:8px;padding:8px 12px;background:#e5e7eb;color:#111827;font-weight:700;cursor:pointer}
button.primary{background:var(--accent);color:#fff}
button.ghost{background:#f3f4f6}
button:disabled{opacity:.45;cursor:not-allowed}
.board{background:#fff;border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:0 8px 20px rgba(0,0,0,.08)}
.grid{display:grid;grid-template-columns:repeat(27,28px);grid-auto-rows:28px;gap:4px;justify-content:center;padding:10px}
.cell{width:28px;height:28px;border-radius:6px;position:relative}
.tile{background:var(--tile);border:1px solid #d7dbe1}
.cp{background:var(--cp)!important}
.det{background:var(--det)!important}
.center{background:var(--center)!important;border-style:dashed}
.highlight{outline:3px dashed #94a3b8;outline-offset:1px;cursor:pointer}
.piece{position:absolute;inset:0;display:grid;place-items:center;font-size:20px}
.piece.active{font-size:22px}
.piece.carry::after{content:'üß∫'; position:absolute; right:-6px; top:-10px; font-size:14px;}
.ring{position:absolute;inset:-2px;border-radius:8px;border:2px solid var(--accent);pointer-events:none}
/* Merged final step styles */
.center.merged-final{position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px}
.piece.basket{position:absolute;top:2px;right:2px;font-size:14px;z-index:10}
.piece.left-piece{position:relative;margin-right:4px}
.piece.right-piece{position:relative;margin-left:4px}
.center.merged-final .piece{display:inline-block;margin:0 1px}
.dir{position:absolute; bottom:-10px; left:2px; font-size:12px; color:#374151}
.dice{display:flex;gap:8px;align-items:center}
.die{width:34px;height:34px;border-radius:8px;background:#111827;color:#fff;display:grid;place-items:center;font-weight:800}
.pairs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.pair{border:1px dashed var(--line);border-radius:10px;padding:6px 10px;background:#fff;cursor:pointer}
.pair.selected{border-color:var(--accent);box-shadow:0 0 0 2px rgba(37,99,235,.15)}
.note{color:var(--muted);font-size:14px;margin-top:10px}
.strip{display:flex;gap:8px;align-items:center;margin:4px 0 6px}
.toast{position:fixed;right:16px;bottom:16px;background:#111827;color:#fff;padding:10px 12px;border-radius:10px;opacity:.95}
.cell small{position:absolute;bottom:1px;right:3px;font-size:9px;color:#6b7280}
.slope{position:absolute;bottom:1px;left:3px;font-size:11px;color:#374151}
.sumLabel{position:relative;top:4px;width:28px;text-align:center;color:#6b7280;font-weight:700}
.warn{color:var(--danger); font-weight:700}
/* Modal */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:20px}
.modal .card{background:#fff;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.25);max-width:760px;width:100%;padding:16px;border:1px solid var(--line)}
.modal .card h3{margin:0 0 8px}
.modal textarea{width:100%;min-height:200px;border:1px solid var(--line);border-radius:8px;padding:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace}
.modal .row{display:flex;gap:8px;justify-content:flex-end;margin-top:8px}
.small{font-size:12px;color:#6b7280}
</style>
</head>
<body>
<div class="wrap">
  <div class="strip">
    <h1>Swoop ‚Äî Pass & Play</h1>
    <div class="badges">
      <div class="badge">üêí Monkeys&nbsp;<span id="score0">0</span></div>
      <div class="badge">üïäÔ∏è Seagulls&nbsp;<span id="score1">0</span></div>
    </div>
  </div>

  <div id="status" style="margin:6px 0 2px;font-size:18px;font-weight:700">Loading‚Ä¶</div>

  <div class="controls">
    <button id="rollBtn" class="primary">Roll 3 Dice</button>
    <button id="useMoveBtn" disabled>Use Pair ‚Üí Move</button>
    <button id="useSwoopBtn" disabled>Use Pair ‚Üí Swoop</button>
    <button id="bankBtn" disabled>Bank (Stop)</button>
    <span style="flex:1"></span>
    <button id="newBtn" class="ghost">New Game</button>
    <button id="saveBtn" class="ghost">Save</button>
    <button id="loadBtn" class="ghost">Load</button>
    <button id="qsaveBtn" class="ghost">Quick Save</button>
    <button id="qloadBtn" class="ghost">Quick Load</button>
  </div>

  <div class="dice" id="diceRow"></div>
  <div class="pairs" id="pairRow"></div>

  <div class="board">
    <div class="grid" id="grid"></div>
    <div class="note">
      <strong>Legend:</strong> üß∫ Basket (even sums only); üü° Checkpoint; üü• Deterrent; üêí/üêµ Monkeys; üïäÔ∏è/ü¶Ö Seagulls.<br/>
      Steps count from each shore toward the center. Each roll is 3d6: select any <em>pair</em> of dice. Spend that pair to <strong>Move</strong> (+1 on the lane matching the sum; returning pieces move ‚àí1) or to <strong>Swoop</strong> (adjacent lane; at odd-lane top apply ‚Üë/‚Üì).<br/>
      <em>Bank</em> is only allowed before rolling. If a roll leaves no legal pair-sum moves <em>or</em> Swoops, press <strong>End Turn (Busted)</strong>.<br/>
      Deterrents trigger only on Bank/Bust; checkpoints are safe. <span class="warn">Cells cannot hold more than one piece.</span> Max pieces per player: <strong>5</strong>. Max <em>active pieces this turn</em>: <strong>2</strong>.
    </div>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>

<!-- Load modal -->
<div id="loadModal" class="modal" aria-hidden="true">
  <div class="card">
    <h3>Load Game State</h3>
    <p class="small">Paste a previously saved JSON state below, or choose a file. Loading replaces the current game.</p>
    <textarea id="loadTextarea" placeholder='{"version":"v5.2","players":[...],...}'></textarea>
    <div class="row">
      <input type="file" id="fileInput" accept="application/json"/>
      <span style="flex:1"></span>
      <button id="cancelLoad">Cancel</button>
      <button id="confirmLoad" class="primary">Load</button>
    </div>
  </div>
</div>

<script>
/* ---------- Core board config ---------- */
const lanes = [
  {sum:2, L:3, basket:true},
  {sum:3, L:4, basket:false},
  {sum:4, L:5, basket:true},
  {sum:5, L:6, basket:false},
  {sum:6, L:7, basket:true},
  {sum:7, L:8, basket:false},
  {sum:8, L:7, basket:true},
  {sum:9, L:6, basket:false},
  {sum:10, L:5, basket:true},
  {sum:11, L:4, basket:false},
  {sum:12, L:3, basket:true},
];
function checkpoints(L){ const out=[2]; if(L>=6) out.push(4); out.push(L-1); out.push(L); return [...new Set(out)].filter(x=>x>=1&&x<=L); }
function deterrents(L,sum){ if(L<=3) return []; const det=[3, L-2]; if((sum===6||sum===8)&&L>=5) det.push(5); const cps=checkpoints(L); return [...new Set(det)].filter(x=>x>=1&&x<=L && !cps.includes(x)); }
const oddSlope = {3:+1, 5:-1, 7:-1, 9:-1, 11:+1};

const grid = document.getElementById('grid');
const rows = lanes.length;
const cols = 27;
const centerCol = 13;
const leftStartCol = 1;
const rightEndCol = cols-2;
const leftSpan = centerCol - leftStartCol - 1;
const rightSpan = rightEndCol - centerCol - 1;

const cells = [];
for(let r=0;r<rows;r++){
  const row=[];
  const labelL = document.createElement('div'); labelL.className='cell'; labelL.innerHTML=`<div class="sumLabel">${lanes[r].sum}</div>`; grid.appendChild(labelL); row.push(labelL);
  for(let c=1;c<cols-1;c++){ const d=document.createElement('div'); d.className='cell'; grid.appendChild(d); row.push(d); }
  const labelR = document.createElement('div'); labelR.className='cell'; labelR.innerHTML=`<div class="sumLabel">${lanes[r].sum}</div>`; grid.appendChild(labelR); row.push(labelR);
  cells.push(row);
}
function colForStep(side, step, L){
  // Final step (step L) is always at the center column for both sides
  if(step === L) return centerCol;
  if(side==='L'){ const rel=Math.round((leftSpan-1)*(step-1)/(L-1)); return leftStartCol+rel; }
  const rel=Math.round((rightSpan-1)*(step-1)/(L-1)); return rightEndCol-rel;
}
for(let r=0;r<rows;r++){
  const L=lanes[r].L, sum=lanes[r].sum;
  const cps=checkpoints(L), dets=deterrents(L,sum);

  // Set up steps 1 to L-1 for both sides
  for(let k=1;k<L;k++){
    const cL=colForStep('L',k,L), cR=colForStep('R',k,L);
    const elL=cells[r][cL]; elL.classList.add('tile'); elL.dataset.r=r; elL.dataset.side='L'; elL.dataset.step=k;
    const elR=cells[r][cR]; elR.classList.add('tile'); elR.dataset.r=r; elR.dataset.side='R'; elR.dataset.step=k;
    if(cps.includes(k)){ elL.classList.add('cp'); elR.classList.add('cp'); }
    if(dets.includes(k)){ elL.classList.add('det'); elR.classList.add('det'); }
    const sL=document.createElement('small'); sL.textContent=k; elL.appendChild(sL);
    const sR=document.createElement('small'); sR.textContent=k; elR.appendChild(sR);
  }

  // Set up the merged final step at center column
  const center=cells[r][centerCol];
  center.classList.add('tile','center','merged-final');
  center.dataset.r=r;
  center.dataset.step=L;
  if(cps.includes(L)){ center.classList.add('cp'); }
  if(dets.includes(L)){ center.classList.add('det'); }
  const stepNum=document.createElement('small'); stepNum.textContent=L; center.appendChild(stepNum);
  if(lanes[r].basket){ const b=document.createElement('div'); b.className='piece basket'; b.textContent='üß∫'; center.appendChild(b); }
}

/* ---------- Helpers & state ---------- */
function occupied(r, side, step){
  // For the final step (merged step), allow both sides to occupy it
  const L = lanes[r].L;
  if (step === L) {
    // Check if the same side already has a piece on the final step
    for(let pi=0; pi<players.length; pi++){
      for(const pc of players[pi].pieces){
        if(pc.r===r && pc.side===side && pc.step===step) return true;
      }
    }
    return false;
  }

  // For non-final steps, use original logic
  for(let pi=0; pi<players.length; pi++){
    for(const pc of players[pi].pieces){
      if(pc.r===r && pc.side===side && pc.step===step) return true;
    }
  }
  return false;
}
function pieceOnLane(pl, r){ return pl.pieces.find(p=>p.r===r); }
function activeCount(pl){ return pl.pieces.filter(p=>p.active===true).length; }
function isActiveForCurrent(pl, pc){ return pc.active===true; }

const players=[
  {name:'Monkeys', pieceIcon:'üêí', activeIcon:'üêµ', score:0, pieces:[]},
  {name:'Seagulls', pieceIcon:'üïäÔ∏è', activeIcon:'ü¶Ö', score:0, pieces:[]}
];
// piece: {r, side:'L'|'R', step, carrying:boolean, active:boolean}

let current=0;
let rolled=null;
let selectedPair=null;
let mode='preroll';
let topStepPiece=null;
let topStepTargets=null;
let tailwindPiece=null;
let tailwindOptions=null;
let tailwindSwoopTargets=null;

const statusEl=document.getElementById('status');
const rollBtn=document.getElementById('rollBtn');
const useMoveBtn=document.getElementById('useMoveBtn');
const useSwoopBtn=document.getElementById('useSwoopBtn');
const bankBtn=document.getElementById('bankBtn');
const newBtn=document.getElementById('newBtn');
const saveBtn=document.getElementById('saveBtn');
const loadBtn=document.getElementById('loadBtn');
const qsaveBtn=document.getElementById('qsaveBtn');
const qloadBtn=document.getElementById('qloadBtn');
const diceRow=document.getElementById('diceRow');
const pairRow=document.getElementById('pairRow');
const toastEl=document.getElementById('toast');

/* ---------- UI helpers ---------- */
function toast(m){ toastEl.textContent=m; toastEl.style.display='block'; setTimeout(()=>toastEl.style.display='none',1500); }

function locate(r, side, step){
  if(step===999) return cells[r][centerCol];
  const L=lanes[r].L; if(step<1 || step> L) return null;
  // Final step is always at center column regardless of side
  if(step === L) return cells[r][centerCol];
  const c=colForStep(side,step,L); return cells[r][c];
}

function clearPieces(){
  for(const row of cells) for(const el of row){
    const old=el.querySelectorAll('.piece,.ring,.slope,.dir');
    old.forEach(n=>n.remove());
    el.classList.remove('highlight'); el.onclick=null;
  }
  // Center baskets (visual only)
  for(let r=0;r<rows;r++){
    const ce=cells[r][centerCol];
    if(lanes[r].basket && !ce.querySelector('.piece')){
      const b=document.createElement('div'); b.className='piece'; b.textContent='üß∫'; ce.appendChild(b);
    }
  }
}
function placePieces(){
  for(let pi=0; pi<players.length; pi++){
    const pl=players[pi];
    for(const pc of pl.pieces){
      const el=locate(pc.r, pc.side, pc.step); if(!el) continue;
      const div=document.createElement('div'); 
      const useActiveIcon = (pi===current && isActiveForCurrent(pl,pc));
      div.className='piece'+(useActiveIcon?' active':'');
      div.textContent = useActiveIcon ? pl.activeIcon : pl.pieceIcon;
      if(pc.carrying){ div.classList.add('carry'); const d=document.createElement('div'); d.className='dir'; d.textContent='‚Ü©'; el.appendChild(d); }
      el.appendChild(div);
      if(useActiveIcon){ const ring=document.createElement('div'); ring.className='ring'; el.appendChild(ring); }
    }
  }
}
function renderScores(){ document.getElementById('score0').textContent=players[0].score; document.getElementById('score1').textContent=players[1].score; }

function checkVictory(){
  const TARGET_SCORE = 2;
  for(let i = 0; i < players.length; i++){
    if(players[i].score >= TARGET_SCORE){
      mode = 'gameOver';
      statusEl.textContent = `üéâ ${players[i].name} wins with ${players[i].score} deliveries!`;
      rollBtn.disabled = true;
      useMoveBtn.disabled = true;
      useSwoopBtn.disabled = true;
      bankBtn.disabled = true;
      return true;
    }
  }
  return false;
}

function tryPickupBasket(pc){
  const L=lanes[pc.r].L;
  if(pc.step===L && lanes[pc.r].basket && !pc.carrying){
    const ce=cells[pc.r][centerCol];
    const basket=ce.querySelector('.piece');
    if(basket){
      basket.remove();
      pc.carrying=true;
      toast('Picked up basket!');
      return true;
    }
  }
  return false;
}

/* ---------- Buttons enable/disable ---------- */
function canSwoopThisRoll(){
  if(!(mode==='pairChosen' && selectedPair)) return false;
  const pl=players[current];
  const selectedSum = selectedPair.sum;
  const selectedLaneIndex = lanes.findIndex(lane => lane.sum === selectedSum);

  // Only pieces on lanes adjacent to the selected sum can swoop
  const adjacentLaneIndices = [selectedLaneIndex - 1, selectedLaneIndex + 1].filter(idx => idx >= 0 && idx < lanes.length);
  const adjacentSums = adjacentLaneIndices.map(idx => lanes[idx].sum);

  const eligiblePieces = pl.pieces.filter(p => p.active && adjacentSums.includes(lanes[p.r].sum));
  if(eligiblePieces.length===0) return false;
  for(const pc of eligiblePieces){
    const dests = potentialSwoops(pc);
    if(dests.length>0) return true;
  }
  return false;
}
function anyMandatoryActionThisRoll(){ return existsAnyMoveThisRoll(); }
function anyActionThisRoll(){ return existsAnyMoveThisRoll() || canSwoopThisRoll(); }

function render(){
  clearPieces(); placePieces(); renderScores();

  // Handle game over mode
  if(mode === 'gameOver') {
    rollBtn.disabled = true;
    useMoveBtn.disabled = true;
    useSwoopBtn.disabled = true;
    bankBtn.disabled = true;
    return;
  }

  rollBtn.disabled = !(mode==='preroll');
  const canMove = (mode==='pairChosen' && selectedPair && canMoveOnSum(players[current], selectedPair.sum));
  useMoveBtn.disabled = !canMove;
  const canSwoop = canSwoopThisRoll();
  useSwoopBtn.disabled = !canSwoop;
  if(mode==='rolled' || mode==='pairChosen'){
    const mandatory = anyMandatoryActionThisRoll();
    const any = anyActionThisRoll();
    if(mandatory) {
      bankBtn.textContent = 'Must Move';
      bankBtn.disabled = true;
    } else if(any) {
      bankBtn.textContent = 'Bank (Stop)';
      bankBtn.disabled = false;
    } else {
      bankBtn.textContent = 'End Turn (Busted)';
      bankBtn.disabled = false;
    }
  }else{ bankBtn.textContent='Bank (Stop)'; bankBtn.disabled=!(mode==='preroll'); }
}

/* ---------- Start/Next ---------- */
function startGame(){ 
  players[0].pieces=[]; players[1].pieces=[]; players[0].score=0; players[1].score=0;
  current=0; rolled=null; selectedPair=null; mode='preroll';
  diceRow.innerHTML=''; pairRow.innerHTML='';
  render(); statusEl.textContent=`${players[current].name}, roll the dice!`;
}
function nextPlayer(){ 
  players[current].pieces.forEach(p=>p.active=false);
  current=1-current; rolled=null; selectedPair=null; mode='preroll'; diceRow.innerHTML=''; pairRow.innerHTML='';
  render(); statusEl.textContent=`${players[current].name}, roll the dice!`; 
}

/* ---------- Dice / Pairs ---------- */
function r6(){ return 1+Math.floor(Math.random()*6); }
function renderDiceAndPairs(){
  if(!rolled){ diceRow.innerHTML=''; pairRow.innerHTML=''; return; }
  const d=rolled.d;
  diceRow.innerHTML=d.map(v=>`<div class="die">${v}</div>`).join('');
  pairRow.innerHTML=rolled.pairs.map((p,i)=>`<div class="pair ${selectedPair && selectedPair.i===p.i && selectedPair.j===p.j?'selected':''}" data-i="${i}">${d[p.i]} + ${d[p.j]} = <b>${p.sum}</b></div>`).join('');
  Array.from(pairRow.children).forEach(el=>{
    el.onclick=()=>{
      // Allow pair selection from rolled, pairChosen, or swoop modes (to deselect swoop)
      if(mode !== 'rolled' && mode !== 'pairChosen' && mode !== 'chooseSwoop' && mode !== 'pickSwoopDest') return;

      Array.from(pairRow.children).forEach(x=>x.classList.remove('selected'));
      el.classList.add('selected');
      selectedPair=rolled.pairs[+el.dataset.i];
      mode='pairChosen';

      // Clear any swoop-related highlights when switching pairs
      clearHighlights();

      render();
      updateStatusAfterSelect();
    };
  });
}
function roll3(){
  const d=[r6(),r6(),r6()]; rolled={ d, pairs: [[0,1],[0,2],[1,2]].map(([i,j])=>({i,j,sum:d[i]+d[j]})) };
  selectedPair=null; mode='rolled'; renderDiceAndPairs();
  if(!existsAnyMoveThisRoll()){
    render();
    statusEl.textContent=`${players[current].name} rolled ${d.join(' ')} ‚Äî select a pair to Swoop (optional) or End Turn (Busted).`;
  } else {
    render();
    statusEl.textContent=`${players[current].name}: select a pair, then Move or Swoop.`;
  }
}
function updateStatusAfterSelect(){
  if(mode!=='pairChosen') return;
  const canMove = canMoveOnSum(players[current], selectedPair.sum);
  const canSwoop = canSwoopThisRoll();
  if(canMove && canSwoop) statusEl.textContent=`${players[current].name}: Move or Swoop.`;
  else if(canMove) statusEl.textContent=`${players[current].name}: Move.`;
  else if(canSwoop) statusEl.textContent=`${players[current].name}: Swoop (optional) or Bank/Bust.`;
  else statusEl.textContent=`${players[current].name}: End Turn (Busted).`;
}

/* ---------- Move/Swoop rules ---------- */
function existsAnyMoveThisRoll(){
  if(!rolled) return false;
  const pl=players[current];
  for(const pr of rolled.pairs){ if(canMoveOnSum(pl, pr.sum)) return true; }
  return false;
}
function canMoveOnSum(pl, sum){
  const r=lanes.findIndex(x=>x.sum===sum); if(r<0) return false;

  // Get all pieces on this route
  const piecesOnRoute = pl.pieces.filter(p => p.r === r);

  if(piecesOnRoute.length > 0){
    // Check if any piece on this route can move
    // First check active pieces, then inactive pieces
    const activePieces = piecesOnRoute.filter(p => p.active);
    const inactivePieces = piecesOnRoute.filter(p => !p.active);

    // Check active pieces first - they can move if not blocked
    for(const pc of activePieces){
      const L=lanes[pc.r].L;
      if(pc.step === L){
        const targets = getMoveTargets(pc);
        if(targets.length > 0) return true;
        if(canTopStepActivate(pl, pc)) return true;
      } else {
        const targets = getMoveTargets(pc);
        if(targets.length > 0) return true;
      }
    }

    // Check inactive pieces - they can move if they can be activated first
    if(activeCount(pl) < 2){
      for(const pc of inactivePieces){
        const L=lanes[pc.r].L;
        if(pc.step === L){
          const targets = getMoveTargets(pc);
          if(targets.length > 0) return true;
          if(canTopStepActivate(pl, pc)) return true;
        } else {
          const targets = getMoveTargets(pc);
          if(targets.length > 0) return true;
        }
      }
    }
  
    return false;
  } else {
    // No pieces on route - check if we can spawn a new piece
    const side=(pl===players[0])?'L':'R';
    return (pl.pieces.length<5 && !occupied(r, side, 1) && activeCount(pl)<2);
  }
}

// Check if a piece at top step can be activated
function canTopStepActivate(pl, pc){
  return !pc.active && activeCount(pl) < 2;
}

// Check if a piece at top step can move down
function canTopStepMoveDown(pc){
  const L = lanes[pc.r].L;
  if(pc.step !== L) return false;
  const downStep = L - 1;
  return downStep >= 1 && !occupied(pc.r, pc.side, downStep);
}

// Check if a piece at top step can do a free swoop
function canTopStepFreeSwoop(pc){
  if(pc.step !== lanes[pc.r].L) return false;
  return potentialTopStepSwoops(pc).length > 0;
}

// Get potential swoop targets for a piece at top step
function potentialTopStepSwoops(pc){
  const targets = [];
  const r = pc.r;
  const L = lanes[r].L;

  if(pc.step !== L) return targets;

  for(const dr of [-1, +1]){
    const r2 = r + dr;
    if(r2 < 0 || r2 >= lanes.length) continue;

    const step2 = lanes[r2].L;
    if(!occupied(r2, pc.side, step2)){
      targets.push({r: r2, step: step2});
    }
  }
  return targets;
}

// Get potential move destinations for a piece (up, down, and sideways if at top step)
function getMoveTargets(pc){
  const targets = [];
  const L = lanes[pc.r].L;

  // Up
  const up = pc.step + 1;
  if(up <= L && !occupied(pc.r, pc.side, up)){
    targets.push({r: pc.r, step: up});
  }

  // Down
  const down = pc.step - 1;
  if(down >= 1 && !occupied(pc.r, pc.side, down)){
    targets.push({r: pc.r, step: down});
  }

  // Sideways from top step
  if(pc.step === L){
    for(const dr of [-1, +1]){
      const r2 = pc.r + dr;
      if(r2 < 0 || r2 >= rows) continue;
      const step2 = lanes[r2].L;
      if(!occupied(r2, pc.side, step2)){
        targets.push({r: r2, step: step2});
      }
    }
  }
  return targets;
}
function ensurePieceForSum(pl, sum){
  const r = lanes.findIndex(x=>x.sum===sum);

  // Get all pieces on this route
  const piecesOnRoute = pl.pieces.filter(p => p.r === r);
  const side = (pl===players[0]) ? 'L' : 'R';

  if(piecesOnRoute.length > 0){
    // Prioritize active pieces that can move, then inactive pieces that can be activated
    const activePieces = piecesOnRoute.filter(p => p.active);
    const inactivePieces = piecesOnRoute.filter(p => !p.active);

  // First, try to find an active piece that can move (up or down, or sideways at top)
  for(const pc of activePieces){
    const L = lanes[pc.r].L;

    if(pc.step === L){
      return ensureTopStepPiece(pl, pc);
    }

    const targets = getMoveTargets(pc);
    if(targets.length > 0){
      return pc; // This active piece can move
    }
  }

  // If no active piece can move, try to activate an inactive piece that can move
  if(activeCount(pl) < 2){
    for(const pc of inactivePieces){
      const L = lanes[pc.r].L;

        // Special handling for pieces at top step
        if(pc.step === L){
          return ensureTopStepPiece(pl, pc);
        }

      const targets = getMoveTargets(pc);
      if(targets.length > 0){
        // Activate this piece
        pc.active = true;
        return pc;
      }
    }
  }

    // If we get here, no piece on the route can move
    return null;
  }

  // No pieces on route - try to spawn a new piece
  if(pl.pieces.length>=5 || activeCount(pl)>=2) return null;
  if(occupied(r, side, 1)) return null;
  const pc = {r, side, step:1, carrying:false, active:true};
  pl.pieces.push(pc);
  return pc;
}

// Handle pieces at top step with multiple options
function ensureTopStepPiece(pl, pc){
  // First, try to activate if not already active
  if(!pc.active && activeCount(pl) < 2){
    pc.active = true;
  }
  return pc;
}

// Choose the best action for a piece at top step
function chooseTopStepAction(pc){
  // Prefer move down if carrying (helps get home faster)
  if(pc.carrying && canTopStepMoveDown(pc)){
    return 'move_down';
  }

  // Otherwise prefer free swoop if available
  if(canTopStepFreeSwoop(pc)){
    return 'free_swoop';
  }

  // Default to just activation (no movement)
  return 'activate';
}

// Choose the best target for a top step free swoop
function chooseBestTopStepSwoopTarget(targets, pc){
  if(targets.length === 0) return null;

  // If carrying, prefer lanes that help get home (even sums with baskets)
  if(pc.carrying){
    const basketTargets = targets.filter(t => lanes[t.r].basket);
    if(basketTargets.length > 0){
      return basketTargets[0];
    }
  }

  // Otherwise, prefer higher sum lanes (better positioning)
  targets.sort((a, b) => lanes[b.r].sum - lanes[a.r].sum);
  return targets[0];
}
function afterMovePickup(pc){
  const lane=lanes[pc.r]; const L=lane.L;
  if(lane.basket && pc.step===L && !pc.carrying){
    const ce=cells[pc.r][centerCol]; const basket=ce.querySelector('.piece');
    if(basket){ basket.remove(); pc.carrying=true; toast('Picked up basket!'); }
  }
}
function usePairForMove(){
  if(!(mode==='pairChosen' && selectedPair)) return;
  const pl = players[current]; const s=selectedPair.sum;
  if(!canMoveOnSum(pl, s)){ toast('That sum cannot move.'); return; }
  const beforeCount = pl.pieces.length;
  const pc = ensurePieceForSum(pl, s); if(!pc) { toast('No available piece/slot.'); return; }
  if(pl.pieces.length>beforeCount){
    // just activated new lane; piece remains at step 1
  }else{
    // General movement: up/down anywhere; if at top, also sideways
    const targets = getMoveTargets(pc);
    if(targets.length === 0){
      // No movement possible (maybe just activated)
    } else if(targets.length === 1){
      const target = targets[0];
      pc.r = target.r;
      pc.step = target.step;
      tryPickupBasket(pc);
    } else {
      // Multiple choices ‚Äî let user select destination (up/down/sideways)
      mode = 'chooseMoveDest';
      clearHighlights();
      for(const target of targets){
        const cell = locate(target.r, pc.side, target.step);
        if(cell){
          cell.classList.add('highlight');
          cell.onclick = () => {
            pc.r = target.r;
            pc.step = target.step;
            tryPickupBasket(pc);

            rolled=null; selectedPair=null; mode='preroll';
            diceRow.innerHTML=''; pairRow.innerHTML='';
            clearHighlights();
            render();
            statusEl.textContent = `${pl.name} acted on ${s}. Roll or Bank.`;
          };
        }
      }
      statusEl.textContent = `${pl.name}: Choose Up, Down, or Sideways.`;
      return;
    }
  }
  rolled=null; selectedPair=null; mode='preroll'; diceRow.innerHTML=''; pairRow.innerHTML='';
  render(); statusEl.textContent = `${pl.name} acted on ${s}. Roll or Bank.`;
}
function potentialSwoops(pc){
  const targets=[]; const r=pc.r; const L=lanes[r].L; const sum=lanes[r].sum;
  const atOddTop = (sum%2===1) && (pc.step===L-1);
  const atTopStep = pc.step===L;

  for(const dr of [-1,+1]){
    const r2=r+dr; if(r2<0||r2>=rows) continue;
    let step2 = pc.step;

    if(atOddTop){
      // Special slope adjustment for pieces at L-1 on odd lanes
      step2 = Math.min(lanes[r2].L, Math.max(1, pc.step + oddSlope[sum]));
    } else if(atTopStep){
      // Pieces at the top step can swoop to the top step of adjacent lanes
      step2 = lanes[r2].L;
    }

    step2 = Math.min(lanes[r2].L, step2);
    if(!occupied(r2, pc.side, step2)) targets.push({r:r2, step:step2});
  }
  return targets;
}
function usePairForSwoop(){
  if(!(mode==='pairChosen' && selectedPair)) return;
  const pl=players[current];
  const selectedSum = selectedPair.sum;
  const selectedLaneIndex = lanes.findIndex(lane => lane.sum === selectedSum);

  // Only pieces on lanes adjacent to the selected sum can swoop
  const adjacentLaneIndices = [selectedLaneIndex - 1, selectedLaneIndex + 1].filter(idx => idx >= 0 && idx < lanes.length);
  const adjacentSums = adjacentLaneIndices.map(idx => lanes[idx].sum);

  const eligiblePieces = pl.pieces.filter(p => p.active && adjacentSums.includes(lanes[p.r].sum));
  if(eligiblePieces.length===0){ toast('No eligible piece to Swoop (must be adjacent to selected sum).'); return; }
  mode='chooseSwoop';
  clearPieces(); placePieces();
  statusEl.textContent = `${pl.name}: click an active piece to Swoop.`;
  for(const pc of eligiblePieces){
    const el = locate(pc.r, pc.side, pc.step); if(!el) continue;
    el.classList.add('highlight'); el.onclick = ()=>{
      clearHighlights();
      const dests = potentialSwoops(pc);
      for(const d of dests){
        const cell = locate(d.r, pc.side, d.step);
        if(!cell) continue;
        cell.classList.add('highlight');
        if((lanes[pc.r].sum%2===1) && (pc.step===lanes[pc.r].L-1)){
          const s=document.createElement('div'); s.className='slope'; s.textContent = (oddSlope[lanes[pc.r].sum]===1?'‚Üë':'‚Üì'); cell.appendChild(s);
        }
        cell.onclick = ()=>{
          pc.r=d.r; pc.step=d.step;
          // Check for basket pickup after swoop
          tryPickupBasket(pc);
          rolled=null; selectedPair=null; diceRow.innerHTML=''; pairRow.innerHTML='';
          render(); triggerTailwindSelection();
        };
      }
    };
  }
}
function clearHighlights(){ for(const row of cells) for(const el of row){ el.classList.remove('highlight'); el.onclick=null; const hints=el.querySelectorAll('.slope'); hints.forEach(n=>n.remove()); } placePieces(); }

/* ---------- Tailwind ---------- */
function triggerTailwindSelection(){
  mode='tailwind'; render();
  const oppIndex = 1-current; const opp = players[oppIndex];
  const side = (oppIndex===0?'L':'R');
  let hasOption=false;
  if(opp.pieces.length>0){
    statusEl.textContent = `${players[oppIndex].name} Tailwind: choose a piece to advance +1, or click a base to spawn.`;
    for(const pc of opp.pieces){
      const el = locate(pc.r, pc.side, pc.step); if(!el) continue;
      const L=lanes[pc.r].L; const dir = pc.carrying ? -1 : +1; const ns = pc.step + dir;

      // Check if this piece can advance
      let canAdvance = false;
      if (ns > L) {
        // Non-carrying piece can advance beyond final step (gets removed)
        canAdvance = !pc.carrying;
      } else if (ns >= 1) {
        // Normal advancement within lane bounds
        canAdvance = !occupied(pc.r, pc.side, ns);
      }

      if (canAdvance) {
        el.classList.add('highlight');
        el.onclick = ()=>{
          if (ns > L && !pc.carrying) {
            // Non-carrying piece at top step - give player choice between swoop and move down
            if (pc.step === L) {
              const canMoveDown = canTopStepMoveDown(pc);
              const canSwoop = canTopStepFreeSwoop(pc);

              if (canMoveDown || canSwoop) {
                // Set up choice mode for tailwind top step options
                mode = 'tailwindTopStepChoice';
                tailwindPiece = pc;
                tailwindOptions = [];
                if (canMoveDown) tailwindOptions.push('move_down');
                if (canSwoop) tailwindOptions.push('swoop');

                clearHighlights();
                showTailwindTopStepChoice();
                return;
              } else {
                // No options available, remove piece
                const index = opp.pieces.indexOf(pc);
                if (index > -1) opp.pieces.splice(index, 1);
              }
            } else {
              // Remove piece that advances beyond final step
              const index = opp.pieces.indexOf(pc);
              if (index > -1) opp.pieces.splice(index, 1);
            }
          } else if (ns >= 1 && ns <= L && !occupied(pc.r, pc.side, ns)) {
            // Normal advancement
            pc.step = ns;
            tryPickupBasket(pc);
          }
          finishTailwind();
        };
        hasOption=true;
      }
    }
    if(opp.pieces.length < 5){
      for(let r=0;r<rows;r++){
        const base = locate(r, side, 1);
        if(base && !occupied(r, side, 1)){
          base.classList.add('highlight'); base.onclick = ()=>{
            opp.pieces.push({r, side, step:1, carrying:false, active:false});
            finishTailwind();
          }; hasOption=true;
        }
      }
    }
  } else {
    statusEl.textContent = `${players[oppIndex].name} Tailwind: click a base (step 1) to spawn a piece.`;
    for(let r=0;r<rows;r++){
      const base = locate(r, side, 1);
      if(base && !occupied(r, side, 1)){
        base.classList.add('highlight'); base.onclick = ()=>{
          opp.pieces.push({r, side, step:1, carrying:false, active:false});
          finishTailwind();
        }; hasOption=true;
      }
    }
  }
  if(!hasOption) finishTailwind();
  function finishTailwind(){
    clearHighlights(); mode='preroll'; render(); statusEl.textContent = `${players[current].name}: Roll or Bank.`;
  }
}

function showTailwindTopStepChoice(){
  const oppIndex = 1-current;
  statusEl.innerHTML = `
    ${players[oppIndex].name} Tailwind: Choose action for piece at top step:<br>
    ${tailwindOptions.includes('move_down') ? '<button onclick="handleTailwindTopStepChoice(\'move_down\')">‚¨áÔ∏è Move Down</button>' : ''}
    ${tailwindOptions.includes('swoop') ? '<button onclick="handleTailwindTopStepChoice(\'swoop\')">üîÑ Swoop</button>' : ''}
  `;
}

function handleTailwindTopStepChoice(action){
  if(mode !== 'tailwindTopStepChoice' || !tailwindPiece) return;

  const oppIndex = 1-current;
  const opp = players[oppIndex];

  // Find the actual piece in the opponent's pieces array
  const actualPiece = opp.pieces.find(p =>
    p.r === tailwindPiece.r && p.step === tailwindPiece.step && p.side === tailwindPiece.side
  );

  if (!actualPiece) {
    finishTailwind();
    return;
  }

  if (action === 'move_down') {
    const L = lanes[actualPiece.r].L;
    const downStep = L - 1;
    if (downStep >= 1 && !occupied(actualPiece.r, actualPiece.side, downStep)) {
      actualPiece.step = downStep;
      tryPickupBasket(actualPiece);
      toast(`Moved down to step ${downStep}`);
    }
  } else if (action === 'swoop') {
    const targets = potentialTopStepSwoops(actualPiece);
    if (targets.length === 1) {
      // Auto-select single target
      const target = targets[0];
      actualPiece.r = target.r;
      actualPiece.step = target.step;
      tryPickupBasket(actualPiece);
      toast(`Swooped to lane ${lanes[target.r].sum}!`);
    } else if (targets.length > 1) {
      // Let player choose swoop target
      mode = 'tailwindChooseSwoop';
      tailwindSwoopTargets = targets;
      showTailwindSwoopChoice();
      return;
    }
  }

  // Clear tailwind state and finish
  mode = null;
  tailwindPiece = null;
  tailwindOptions = null;
  tailwindSwoopTargets = null;
  finishTailwind();
}

function showTailwindSwoopChoice(){
  const oppIndex = 1-current;
  statusEl.textContent = `${players[oppIndex].name}: Choose swoop destination.`;

  // Highlight swoop targets
  for(const target of tailwindSwoopTargets){
    const el = locate(target.r, tailwindPiece.side, target.step);
    if(el){
      el.classList.add('highlight');
      el.onclick = () => handleTailwindSwoopChoice(target);
    }
  }
}

function handleTailwindSwoopChoice(target){
  if(mode !== 'tailwindChooseSwoop' || !tailwindPiece) return;

  const oppIndex = 1-current;
  const opp = players[oppIndex];

  // Find the actual piece in the opponent's pieces array
  const actualPiece = opp.pieces.find(p =>
    p.r === tailwindPiece.r && p.step === tailwindPiece.step && p.side === tailwindPiece.side
  );

  if (actualPiece) {
    actualPiece.r = target.r;
    actualPiece.step = target.step;
    tryPickupBasket(actualPiece);
    toast(`Swooped to lane ${lanes[target.r].sum}!`);
  }

  // Clear tailwind state and finish
  mode = null;
  tailwindPiece = null;
  tailwindOptions = null;
  tailwindSwoopTargets = null;
  finishTailwind();
}

/* ---------- End turn logic ---------- */
function resolveDeterrents(pl){
  pl.pieces = pl.pieces.filter(pc=>{
    const L=lanes[pc.r].L; const sum=lanes[pc.r].sum;
    const dets = deterrents(L,sum);
    const onDet = dets.includes(pc.step);
    if(onDet){
      if(pc.carrying && lanes[pc.r].basket){
        const ce=cells[pc.r][centerCol];
        if(!ce.querySelector('.piece')){ const b=document.createElement('div'); b.className='piece'; b.textContent='üß∫'; ce.appendChild(b); }
      }
      return false;
    }
    return true;
  });
}
function bank(){
  const pl = players[current];
  const kept=[];
  for(const pc of pl.pieces){
    const L=lanes[pc.r].L; const cps = checkpoints(L);
    tryPickupBasket(pc);
    if(pc.carrying){
      kept.push(pc);
    }else{
      let dest = null;
      for(const c of cps){ if(c<=pc.step) dest=c; }
      if(dest===null){ /* falls off */ }
      else { pc.step = dest; kept.push(pc); }
    }
  }
  pl.pieces = kept;
  resolveDeterrents(pl);
  let delivered=0;
  pl.pieces = pl.pieces.filter(pc=>{
    if(pc.carrying && pc.step===1){ delivered++; return false; }
    return true;
  });
  pl.score += delivered; if(delivered) toast(`${pl.name} delivered ${delivered}.`);
  pl.pieces.forEach(p=>p.active=false);

  // Check for victory after delivery
  if(checkVictory()) return;

  nextPlayer();
}
function bust(){
  const pl = players[current];
  const kept=[];
  for(const pc of pl.pieces){
    const L=lanes[pc.r].L; const sum=lanes[pc.r].sum;
    const cps = checkpoints(L); const dets = deterrents(L,sum);
    const onDet = dets.includes(pc.step);
    if(onDet || cps.includes(pc.step)){ kept.push(pc); continue; }
    let dest = null;
    if(pc.carrying){ for(const c of cps){ if(c>=pc.step){ dest=c; break; } } }
    else { for(const c of cps){ if(c<=pc.step) dest=c; } }
    if(dest===null){
      if(pc.carrying && lanes[pc.r].basket){
        const ce=cells[pc.r][centerCol];
        if(!ce.querySelector('.piece')){ const b=document.createElement('div'); b.className='piece'; b.textContent='üß∫'; ce.appendChild(b); }
      }
    } else { pc.step = dest; kept.push(pc); }
  }
  pl.pieces = kept;
  resolveDeterrents(pl);
  pl.pieces.forEach(p=>p.active=false);

  // Check for victory after bust (in case any deliveries occurred)
  if(checkVictory()) return;

  nextPlayer();
}

/* ---------- Save / Load ---------- */
function getState(){
  return {
    version: 'v5.2',
    players: players.map(p=>({name:p.name, score:p.score, pieces:p.pieces.map(x=>({...x}))})),
    current,
    mode,
    rolled: rolled ? {d:[...rolled.d], pairs:[...rolled.pairs]} : null,
    selectedPair: selectedPair ? {...selectedPair} : null
  };
}
function setState(state){
  try{
    players[0].score = state.players[0].score;
    players[1].score = state.players[1].score;
    players[0].pieces = state.players[0].pieces || [];
    players[1].pieces = state.players[1].pieces || [];
    current = (state.current===0 || state.current===1) ? state.current : 0;
    mode = state.mode || 'preroll';
    rolled = state.rolled ? {d:[...state.rolled.d], pairs:[...state.rolled.pairs]} : null;
    selectedPair = state.selectedPair || null;
    renderDiceAndPairs();
    render();
    statusEl.textContent = `Loaded game. ${players[current].name}'s turn.`;
  }catch(e){
    console.error(e); toast('Invalid state.'); 
  }
}
function saveToFile(){
  const blob = new Blob([JSON.stringify(getState(), null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download = 'swoop_state.json'; a.click();
  URL.revokeObjectURL(url);
}
function openLoadModal(){
  document.getElementById('loadTextarea').value='';
  document.getElementById('fileInput').value='';
  document.getElementById('loadModal').style.display='flex';
}
function closeLoadModal(){ document.getElementById('loadModal').style.display='none'; }
function loadFromText(txt){
  try{
    const state = JSON.parse(txt);
    setState(state);
    closeLoadModal();
  }catch(e){ console.error(e); toast('Could not parse JSON.'); }
}
document.getElementById('confirmLoad').onclick = ()=>{
  const txt = document.getElementById('loadTextarea').value.trim();
  if(txt) loadFromText(txt); else toast('Paste JSON or choose a file.');
};
document.getElementById('cancelLoad').onclick = closeLoadModal;
document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0]; if(!f) return;
  const rd = new FileReader();
  rd.onload = ()=> loadFromText(rd.result);
  rd.readAsText(f);
});
function quickSave(){ localStorage.setItem('SWOOP_STATE_V52', JSON.stringify(getState())); toast('Saved to browser.'); }
function quickLoad(){ const txt = localStorage.getItem('SWOOP_STATE_V52'); if(!txt){ toast('No quick save found.'); return; } loadFromText(txt); }

/* ---------- Wire up buttons ---------- */
rollBtn.onclick = ()=>{ if(mode!=='preroll') return; roll3(); };
useMoveBtn.onclick = ()=> usePairForMove();
useSwoopBtn.onclick = ()=> usePairForSwoop();
bankBtn.onclick = ()=>{
  if(mode==='preroll'){ bank(); }
  else if((mode==='rolled' || mode==='pairChosen') && !anyActionThisRoll()){ bust(); }
};
newBtn.onclick = startGame;
saveBtn.onclick = saveToFile;
loadBtn.onclick = openLoadModal;
qsaveBtn.onclick = quickSave;
qloadBtn.onclick = quickLoad;

/* ---------- Kickoff ---------- */
startGame();
</script>
</body>
</html>
